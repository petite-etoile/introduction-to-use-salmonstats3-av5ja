'use strict';

var core = require('@capacitor/core');

/**
 * If one of the storage functions throws, the error object will
 * have a code property that contains one of these values, and the
 * message property will have a message suitable for debug purposes.
 */
exports.StorageErrorType = void 0;
(function (StorageErrorType) {
    /**
     * The key is null or empty.
     */
    StorageErrorType[StorageErrorType["missingKey"] = 0] = "missingKey";
    /**
     * `get()` found the data, but it is corrupted.
     */
    StorageErrorType[StorageErrorType["invalidData"] = 1] = "invalidData";
    /**
     * A system-level error occurred when getting/setting data from/to the store.
     */
    StorageErrorType[StorageErrorType["osError"] = 2] = "osError";
    /**
     * An unclassified system-level error occurred.
     */
    StorageErrorType[StorageErrorType["unknownError"] = 3] = "unknownError";
})(exports.StorageErrorType || (exports.StorageErrorType = {}));

class StorageError extends Error {
    constructor(message, code) {
        super(message);
        this.code = exports.StorageErrorType[code];
    }
}
// eslint-disable-next-line import/prefer-default-export
class SecureStorageBase extends core.WebPlugin {
    constructor() {
        super(...arguments);
        this.prefix = 'capacitor-storage_';
        this.sync = false;
    }
    async setSynchronize(sync) {
        this.sync = sync;
        if (core.Capacitor.getPlatform() === 'ios') {
            return this.setSynchronizeKeychain({ sync });
        }
        // no-op on other platforms
        return Promise.resolve();
    }
    async getSynchronize() {
        return Promise.resolve(this.sync);
    }
    async get(key, convertDate = true, sync) {
        if (key) {
            const { data } = await this.internalGetItem({
                prefixedKey: this.prefixedKey(key),
                sync: sync !== null && sync !== void 0 ? sync : this.sync,
            });
            if (data === null) {
                return null;
            }
            if (convertDate) {
                const date = parseISODate(data);
                if (date) {
                    return date;
                }
            }
            try {
                // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
                return JSON.parse(data);
            }
            catch (e) {
                throw new StorageError('Invalid data', exports.StorageErrorType.invalidData);
            }
        }
        return SecureStorageBase.missingKey();
    }
    async getItem(key) {
        if (key) {
            const { data } = await this.internalGetItem({
                prefixedKey: this.prefixedKey(key),
                sync: this.sync,
            });
            return data;
        }
        return null;
    }
    async set(key, data, convertDate = true, sync) {
        if (key) {
            let convertedData = data;
            if (convertDate && data instanceof Date) {
                convertedData = data.toISOString();
            }
            return this.internalSetItem({
                prefixedKey: this.prefixedKey(key),
                data: JSON.stringify(convertedData),
                sync: sync !== null && sync !== void 0 ? sync : this.sync,
            });
        }
        return SecureStorageBase.missingKey();
    }
    async setItem(key, value) {
        if (key) {
            return this.internalSetItem({
                prefixedKey: this.prefixedKey(key),
                data: value,
                sync: this.sync,
            });
        }
        return SecureStorageBase.missingKey();
    }
    async remove(key, sync) {
        if (key) {
            const { success } = await this.internalRemoveItem({
                prefixedKey: this.prefixedKey(key),
                sync: sync !== null && sync !== void 0 ? sync : this.sync,
            });
            return success;
        }
        return SecureStorageBase.missingKey();
    }
    async removeItem(key) {
        if (key) {
            await this.internalRemoveItem({
                prefixedKey: this.prefixedKey(key),
                sync: this.sync,
            });
            return;
        }
        SecureStorageBase.missingKey();
    }
    async keys(sync) {
        const { keys } = await this.getPrefixedKeys({
            prefix: this.prefix,
            sync: sync !== null && sync !== void 0 ? sync : this.sync,
        });
        const prefixLength = this.prefix.length;
        return keys.map((key) => key.slice(prefixLength));
    }
    async getKeyPrefix() {
        return Promise.resolve(this.prefix);
    }
    async setKeyPrefix(prefix) {
        this.prefix = prefix;
        return Promise.resolve();
    }
    prefixedKey(key) {
        return this.prefix + key;
    }
    static missingKey() {
        throw new StorageError('No key provided', exports.StorageErrorType.missingKey);
    }
}
// RegExp to match an ISO 8601 date string in the form YYYY-MM-DDTHH:mm:ss.sssZ
const isoDateRE = /^"(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}).(\d{3})Z"$/u;
function parseISODate(isoDate) {
    const match = isoDateRE.exec(isoDate);
    if (match) {
        /* eslint-disable @typescript-eslint/no-magic-numbers */
        const year = parseInt(match[1], 10);
        const month = parseInt(match[2], 10) - 1; // month is zero-based
        const day = parseInt(match[3], 10);
        const hour = parseInt(match[4], 10);
        const minute = parseInt(match[5], 10);
        const second = parseInt(match[6], 10);
        const millis = parseInt(match[7], 10);
        const epochTime = Date.UTC(year, month, day, hour, minute, second, millis);
        return new Date(epochTime);
        /* eslint-enable */
    }
    return null;
}

const proxy = core.registerPlugin('SecureStorage', {
    web: async () => Promise.resolve().then(function () { return web; }).then((module) => new module.SecureStorageWeb()),
    ios: async () => Promise.resolve().then(function () { return native; }).then((module) => new module.SecureStorageNative(proxy)),
    android: async () => Promise.resolve().then(function () { return native; }).then((module) => new module.SecureStorageNative(proxy)),
});

// eslint-disable-next-line import/prefer-default-export
class SecureStorageWeb extends SecureStorageBase {
    // @native
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async setSynchronizeKeychain(options) {
        return Promise.resolve();
    }
    // @native
    // eslint-disable-next-line @typescript-eslint/require-await
    async internalGetItem(options) {
        return { data: localStorage.getItem(options.prefixedKey) };
    }
    // @native
    async internalSetItem(options) {
        localStorage.setItem(options.prefixedKey, options.data);
        return Promise.resolve();
    }
    // @native
    async internalRemoveItem(options) {
        const item = localStorage.getItem(options.prefixedKey);
        if (item !== null) {
            localStorage.removeItem(options.prefixedKey);
            return Promise.resolve({ success: true });
        }
        return Promise.resolve({ success: false });
    }
    async clear() {
        const { keys } = await this.getPrefixedKeys({ prefix: this.prefix });
        keys.forEach((key) => {
            localStorage.removeItem(key);
        });
        return Promise.resolve();
    }
    // @native
    // eslint-disable-next-line @typescript-eslint/require-await,@typescript-eslint/no-unused-vars
    async clearItemsWithPrefix(options) {
        this.unimplemented('clearItemsWithPrefix is native only');
    }
    // @native
    async getPrefixedKeys(options) {
        const keys = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key === null || key === void 0 ? void 0 : key.startsWith(options.prefix)) {
                keys.push(key);
            }
        }
        return Promise.resolve({ keys });
    }
}

var web = /*#__PURE__*/Object.freeze({
    __proto__: null,
    SecureStorageWeb: SecureStorageWeb
});

// eslint-disable-next-line import/prefer-default-export
class SecureStorageNative extends SecureStorageBase {
    constructor(capProxy) {
        super();
        // capProxy is a proxy of an instance of this class, so it is safe
        // to cast it to this class.
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        const proxy = capProxy;
        /* eslint-disable @typescript-eslint/unbound-method */
        this.setSynchronizeKeychain = proxy.setSynchronizeKeychain;
        this.internalGetItem = proxy.internalGetItem;
        this.internalSetItem = proxy.internalSetItem;
        this.internalRemoveItem = proxy.internalRemoveItem;
        this.clearItemsWithPrefix = proxy.clearItemsWithPrefix;
        this.getPrefixedKeys = proxy.getPrefixedKeys;
        /* eslint-enable */
    }
    // @native
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async setSynchronizeKeychain(options) {
        return Promise.resolve();
    }
    // @native
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async internalGetItem(options) {
        return Promise.resolve({ data: '' });
    }
    // @native
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async internalSetItem(options) {
        return Promise.resolve();
    }
    // @native
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async internalRemoveItem(options) {
        return Promise.resolve({ success: true });
    }
    async clear(sync) {
        return this.clearItemsWithPrefix({
            prefix: this.prefix,
            sync: sync !== null && sync !== void 0 ? sync : this.sync,
        });
    }
    // @native
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async clearItemsWithPrefix(options) {
        return Promise.resolve();
    }
    // @native
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async getPrefixedKeys(options) {
        return Promise.resolve({ keys: [] });
    }
}

var native = /*#__PURE__*/Object.freeze({
    __proto__: null,
    SecureStorageNative: SecureStorageNative
});

exports.SecureStorage = proxy;
exports.StorageError = StorageError;
