import { Capacitor, WebPlugin } from '@capacitor/core';
import { StorageErrorType } from './definitions';
export class StorageError extends Error {
    constructor(message, code) {
        super(message);
        this.code = StorageErrorType[code];
    }
}
// eslint-disable-next-line import/prefer-default-export
export class SecureStorageBase extends WebPlugin {
    constructor() {
        super(...arguments);
        this.prefix = 'capacitor-storage_';
        this.sync = false;
    }
    async setSynchronize(sync) {
        this.sync = sync;
        if (Capacitor.getPlatform() === 'ios') {
            return this.setSynchronizeKeychain({ sync });
        }
        // no-op on other platforms
        return Promise.resolve();
    }
    async getSynchronize() {
        return Promise.resolve(this.sync);
    }
    async get(key, convertDate = true, sync) {
        if (key) {
            const { data } = await this.internalGetItem({
                prefixedKey: this.prefixedKey(key),
                sync: sync !== null && sync !== void 0 ? sync : this.sync,
            });
            if (data === null) {
                return null;
            }
            if (convertDate) {
                const date = parseISODate(data);
                if (date) {
                    return date;
                }
            }
            try {
                // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
                return JSON.parse(data);
            }
            catch (e) {
                throw new StorageError('Invalid data', StorageErrorType.invalidData);
            }
        }
        return SecureStorageBase.missingKey();
    }
    async getItem(key) {
        if (key) {
            const { data } = await this.internalGetItem({
                prefixedKey: this.prefixedKey(key),
                sync: this.sync,
            });
            return data;
        }
        return null;
    }
    async set(key, data, convertDate = true, sync) {
        if (key) {
            let convertedData = data;
            if (convertDate && data instanceof Date) {
                convertedData = data.toISOString();
            }
            return this.internalSetItem({
                prefixedKey: this.prefixedKey(key),
                data: JSON.stringify(convertedData),
                sync: sync !== null && sync !== void 0 ? sync : this.sync,
            });
        }
        return SecureStorageBase.missingKey();
    }
    async setItem(key, value) {
        if (key) {
            return this.internalSetItem({
                prefixedKey: this.prefixedKey(key),
                data: value,
                sync: this.sync,
            });
        }
        return SecureStorageBase.missingKey();
    }
    async remove(key, sync) {
        if (key) {
            const { success } = await this.internalRemoveItem({
                prefixedKey: this.prefixedKey(key),
                sync: sync !== null && sync !== void 0 ? sync : this.sync,
            });
            return success;
        }
        return SecureStorageBase.missingKey();
    }
    async removeItem(key) {
        if (key) {
            await this.internalRemoveItem({
                prefixedKey: this.prefixedKey(key),
                sync: this.sync,
            });
            return;
        }
        SecureStorageBase.missingKey();
    }
    async keys(sync) {
        const { keys } = await this.getPrefixedKeys({
            prefix: this.prefix,
            sync: sync !== null && sync !== void 0 ? sync : this.sync,
        });
        const prefixLength = this.prefix.length;
        return keys.map((key) => key.slice(prefixLength));
    }
    async getKeyPrefix() {
        return Promise.resolve(this.prefix);
    }
    async setKeyPrefix(prefix) {
        this.prefix = prefix;
        return Promise.resolve();
    }
    prefixedKey(key) {
        return this.prefix + key;
    }
    static missingKey() {
        throw new StorageError('No key provided', StorageErrorType.missingKey);
    }
}
// RegExp to match an ISO 8601 date string in the form YYYY-MM-DDTHH:mm:ss.sssZ
const isoDateRE = /^"(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}).(\d{3})Z"$/u;
function parseISODate(isoDate) {
    const match = isoDateRE.exec(isoDate);
    if (match) {
        /* eslint-disable @typescript-eslint/no-magic-numbers */
        const year = parseInt(match[1], 10);
        const month = parseInt(match[2], 10) - 1; // month is zero-based
        const day = parseInt(match[3], 10);
        const hour = parseInt(match[4], 10);
        const minute = parseInt(match[5], 10);
        const second = parseInt(match[6], 10);
        const millis = parseInt(match[7], 10);
        const epochTime = Date.UTC(year, month, day, hour, minute, second, millis);
        return new Date(epochTime);
        /* eslint-enable */
    }
    return null;
}
